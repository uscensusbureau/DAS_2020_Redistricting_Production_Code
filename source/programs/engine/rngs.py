"""
Module implementing the DASRandom, the random number generator used by DAS.
Usage:
from programs.engine.rngs import DASRandom
rng_factory = DASRandom
rng = rng_factory().randomState()
rng.geometric(p) retruns a random geometric
RNGs (primarily those, based on hardware, i.e. using RDRAND instruction)
and wrapping them into an interface identical to numpy.random for calling distributions
"""
import logging
import os
import numpy as np


class RDRandLbitInts:
    """
    Class using raw bytes (or rather 8-byte chunks in the form of int64) generated by RDRAND,
    one by one, stacking them to the required amount of random bytes, then XORing that with the same number of bytes from /dev/urandom and
    converting into uniformly distributed integers over given range using one of the rejection sampling algorithms
    """

    def __init__(self):
        import randomgen
        self.bitgen = randomgen.RDRAND()

    def _nextint(self, n_int64_draws):
        """
        Draw next n_int64_draws random int64 from RDRAND generator and stack them into an int of n_int64_draws bits
        :param n_int64_draws: how many int64 draws are needed (1 for int64, 2 for int128 etc)
        :return: n_int64_draws * 64 bit random integer
        """

        # Instead of calling .random_raw() with size argument make int64 draws one by one
        # in our own loop. Calling with size will do the same anyway, creating np.array and spending more time.
        # And we shift bits in the same loop
        s = 0
        for i in range(n_int64_draws):
            s += self.bitgen.random_raw() << (64 * i)                                   # RDRAND random_raw() returns 64bit uint by default
        # XOR RDRANDs result with /dev/urandom for multiple entropy sources
        s = s ^ int.from_bytes(os.urandom(n_int64_draws * 8), 'big')  # os.urandom takes number of bytes to generate, so *8
        return s

    def integers(self, low=0, high=0):
        """
        OpenBSD rejection sampling method for mapping [0..2^L) uniformly distributed integers to [0..s)
        uniformly distributed integers using, which is also used by NumPy.

        Require: source of uniformly-distributed random integers in [0, 2L)   (here by repeated draws of int64 and taking appropriate number of bits)
        Require: target interval [0, s) with s ∈ [0, 2L)
            1: t ← (2^L − s) mod s                                      {(2L − s) mod s = 2L mod s}
            2: x ← random integer in [0, 2^L)
            3: while x < t do                                          {Application of the rejection method}
            4:     x ← random integer in [0, 2^L)
            5: end while
            6: return x mod s

        https://arxiv.org/abs/1805.10941 (Algorithm 3, page 4)
        (Algorithm 3, OpenBSD, is the simplest, Lemire Algorithm 5 doesn't offer considerable performance in Python)
        """
        rangelen = high - low

        if rangelen < 1:
            raise ValueError(f"Interval length is not positive, high={high}, low={low}")

        # Ones and twos are pretty frequent for Discrete Laplace and Gaussian, so worth checking and returning the result directly
        if rangelen == 1:
            return low

        if rangelen == 2:
            rdrand = self.bitgen.random_raw() >> 63 # Get 1 bit (first)
            devurand = os.urandom(1)[0] >> 7        # Get 1 bit (first)
            return low + (rdrand ^ devurand)
            # # The following is a bit slower, but keeps /dev/urandom and XOR in one place
            # return low + (self._nextint(1) >> 63)  # Get 1 bit (first)


        L = 64  # int [0, 2^L) where L is number of bits
        while rangelen >= 1 << L:
            L += 64  # int [0, 2^L) where L is number of bits

        # The line below would achieve the same as the loop above, but is way less tranparent. Removed 6 lines of comments explaining why it is this.
        # L = ((rangelen.bit_length() + 63) & (~0b111111) if rangelen >= (1 << 64) else 64)

        two_to_L = 1 << L  # 2^L

        draws = L // 64  # We know L is multiple of 64

        threshold = (two_to_L - rangelen) % rangelen     # 1: t ← (2^L − s) mod s
        random_Lbit = self._nextint(draws)               # 2: x ← random integer in [0, 2^L)
        while random_Lbit < threshold:                   # 3: while x < t do
            random_Lbit = self._nextint(draws)           # 4: x ← random integer in [0, 2^L)

        return low + (random_Lbit % rangelen)            # 6: return x mod s

    def randint(self, *args, **kwargs):
        return self.integers(*args, **kwargs)

def DASRandom():
    """Return the RNG used by the DAS"""
    logging.info("Using randomgen.RDRAND() as random bit generator")
    import randomgen
    return np.random.Generator(randomgen.RDRAND())


def DASRDRandIntegers():
    return RDRandLbitInts()
