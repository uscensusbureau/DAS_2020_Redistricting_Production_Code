#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This file was automatically generated by ../etl_2020/census_etl/spec_scanner.py on Fri Oct 30 14:06:08 2020
# Command line: ../etl_2020/census_etl/spec_scanner.py ../etl_2020/cef/ADO-DEV-CEF_FOR_CDL_Layouts-2020DRPS-20200611.xlsx --output_parser ../das_decennial/programs/reader/cef_2020/cef_validator_classes.py --tablenames CEF20_UNIT CEF20_PERSON CEF20_CNT

# Automatically generated on Fri Oct 30 14:06:08 2020 by /mnt/users/will0555/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError) as e:
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError) as e:
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError) as e:
        return None


class CEF20_UNIT_validator:
    @classmethod
    def is_valid_RTYPE(self,x):
        """Record Type"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1))
    @classmethod
    def is_valid_MAFID(self,x):
        """(Primary Key) Master Address File ID.  (The unique identifier of Permanent MAFUNIT ID)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (100000001 <= x <= 899999999)
    @classmethod
    def is_valid_BCUSTATEFP(self,x):
        """FIPS State Code. Basic Collection Unit State Code"""
        if x is None or x == "None":
            return False
        return (between('53',x,'56',2)) or (between('04',x,'06',2)) or (between('15',x,'42',2)) or (between('08',x,'13',2)) or (between('01',x,'02',2)) or (leftpad(x,2)==leftpad('72',2)) or (between('44',x,'51',2))
    @classmethod
    def is_valid_VERSION(self,x):
        """Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000 <= x <= 99999)
    @classmethod
    def is_valid_FINAL_POP(self,x):
        """Final Population Count"""
        if x is None or x == "None":
            return False
        return (between('0',x,'99999',5))
    @classmethod
    def is_valid_HHLDRAGE(self,x):
        """Edited Age of Householder"""
        if x is None or x == "None":
            return False
        if x == '   ':
            return True
        return (between('15',x,'115',3))
    @classmethod
    def is_valid_HHSPAN(self,x):
        """Hispanic Householder"""
        if x is None or x == "None":
            return False
        if x == ' ':
            return True
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('2',1))
    @classmethod
    def is_valid_HHLDRACE(self,x):
        """Edited QRACEX of Householder"""
        if x is None or x == "None":
            return False
        if x == ' ':
            return True
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_HHRACE(self,x):
        """Edited CENRACE of Householder"""
        if x is None or x == "None":
            return False
        if x == '  ':
            return True
        return (leftpad(x,2)==leftpad('11',2)) or (leftpad(x,2)==leftpad('15',2)) or (leftpad(x,2)==leftpad('07',2)) or (leftpad(x,2)==leftpad('08',2)) or (leftpad(x,2)==leftpad('14',2)) or (leftpad(x,2)==leftpad('17',2)) or (leftpad(x,2)==leftpad('25',2)) or (leftpad(x,2)==leftpad('45',2)) or (leftpad(x,2)==leftpad('06',2)) or (leftpad(x,2)==leftpad('18',2)) or (leftpad(x,2)==leftpad('27',2)) or (leftpad(x,2)==leftpad('60',2)) or (leftpad(x,2)==leftpad('48',2)) or (leftpad(x,2)==leftpad('59',2)) or (leftpad(x,2)==leftpad('61',2)) or (leftpad(x,2)==leftpad('63',2)) or (leftpad(x,2)==leftpad('35',2)) or (leftpad(x,2)==leftpad('43',2)) or (leftpad(x,2)==leftpad('03',2)) or (leftpad(x,2)==leftpad('21',2)) or (leftpad(x,2)==leftpad('01',2)) or (leftpad(x,2)==leftpad('22',2)) or (leftpad(x,2)==leftpad('33',2)) or (leftpad(x,2)==leftpad('36',2)) or (leftpad(x,2)==leftpad('40',2)) or (leftpad(x,2)==leftpad('24',2)) or (leftpad(x,2)==leftpad('26',2)) or (leftpad(x,2)==leftpad('38',2)) or (leftpad(x,2)==leftpad('49',2)) or (leftpad(x,2)==leftpad('51',2)) or (leftpad(x,2)==leftpad('52',2)) or (leftpad(x,2)==leftpad('05',2)) or (leftpad(x,2)==leftpad('28',2)) or (leftpad(x,2)==leftpad('29',2)) or (leftpad(x,2)==leftpad('54',2)) or (leftpad(x,2)==leftpad('12',2)) or (leftpad(x,2)==leftpad('19',2)) or (leftpad(x,2)==leftpad('44',2)) or (leftpad(x,2)==leftpad('50',2)) or (leftpad(x,2)==leftpad('58',2)) or (leftpad(x,2)==leftpad('62',2)) or (leftpad(x,2)==leftpad('32',2)) or (leftpad(x,2)==leftpad('47',2)) or (leftpad(x,2)==leftpad('55',2)) or (leftpad(x,2)==leftpad('09',2)) or (leftpad(x,2)==leftpad('16',2)) or (leftpad(x,2)==leftpad('20',2)) or (leftpad(x,2)==leftpad('23',2)) or (leftpad(x,2)==leftpad('31',2)) or (leftpad(x,2)==leftpad('37',2)) or (leftpad(x,2)==leftpad('13',2)) or (leftpad(x,2)==leftpad('41',2)) or (leftpad(x,2)==leftpad('42',2)) or (leftpad(x,2)==leftpad('46',2)) or (leftpad(x,2)==leftpad('56',2)) or (leftpad(x,2)==leftpad('57',2)) or (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('30',2)) or (leftpad(x,2)==leftpad('34',2)) or (leftpad(x,2)==leftpad('39',2)) or (leftpad(x,2)==leftpad('04',2)) or (leftpad(x,2)==leftpad('53',2)) or (leftpad(x,2)==leftpad('10',2))
    @classmethod
    def is_valid_TEN(self,x):
        """Edited Tenure"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_TEN_A(self,x):
        """Edited Tenure Based on Age of Householder"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_TEN_R(self,x):
        """Edited Tenure Based on Householder Race"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_VACS(self,x):
        """Edited Vacancy Status"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('7',1))
    @classmethod
    def is_valid_QGQTYP(self,x):
        """Edited Group Quarters Type Code"""
        if x is None or x == "None":
            return False
        if x == '   ':
            return True
        return (leftpad(x,3)==leftpad('801',3)) or (leftpad(x,3)==leftpad('403',3)) or (leftpad(x,3)==leftpad('404',3)) or (leftpad(x,3)==leftpad('405',3)) or (leftpad(x,3)==leftpad('706',3)) or (leftpad(x,3)==leftpad('904',3)) or (leftpad(x,3)==leftpad('802',3)) or (leftpad(x,3)==leftpad('101',3)) or (leftpad(x,3)==leftpad('202',3)) or (leftpad(x,3)==leftpad('903',3)) or (leftpad(x,3)==leftpad('401',3)) or (leftpad(x,3)==leftpad('201',3)) or (leftpad(x,3)==leftpad('105',3)) or (leftpad(x,3)==leftpad('106',3)) or (leftpad(x,3)==leftpad('601',3)) or (leftpad(x,3)==leftpad('602',3)) or (leftpad(x,3)==leftpad('901',3)) or (leftpad(x,3)==leftpad('402',3)) or (leftpad(x,3)==leftpad('701',3)) or (leftpad(x,3)==leftpad('102',3)) or (leftpad(x,3)==leftpad('104',3)) or (leftpad(x,3)==leftpad('702',3)) or (leftpad(x,3)==leftpad('704',3)) or (leftpad(x,3)==leftpad('900',3)) or (leftpad(x,3)==leftpad('203',3)) or (leftpad(x,3)==leftpad('103',3)) or (leftpad(x,3)==leftpad('501',3)) or (leftpad(x,3)==leftpad('301',3))
    @classmethod
    def is_valid_GQSEX(self,x):
        """GQ Unit Sex Composition Flag (from final edited sex)"""
        if x is None or x == "None":
            return False
        if x == ' ':
            return True
        return (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('2',1))
    @classmethod
    def is_valid_OIDTB(self,x):
        """Tabulation Block OID"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_HHT(self,x):
        """Household/Family Type"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('7',1))
    @classmethod
    def is_valid_HHT2(self,x):
        """Household/Family Type (Includes Cohabiting)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('05',2)) or (leftpad(x,2)==leftpad('11',2)) or (leftpad(x,2)==leftpad('07',2)) or (leftpad(x,2)==leftpad('08',2)) or (leftpad(x,2)==leftpad('09',2)) or (leftpad(x,2)==leftpad('12',2)) or (leftpad(x,2)==leftpad('03',2)) or (leftpad(x,2)==leftpad('06',2)) or (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('01',2)) or (leftpad(x,2)==leftpad('00',2)) or (leftpad(x,2)==leftpad('04',2)) or (leftpad(x,2)==leftpad('10',2))
    @classmethod
    def is_valid_CPLT(self,x):
        """Couple Type"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_UPART(self,x):
        """Presence and Type of Unmarried Partner Household"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_MULTG(self,x):
        """Multigenerational Household"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))
    @classmethod
    def is_valid_PAOC(self,x):
        """Presence and Age of Own Children Under 18"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_P18(self,x):
        """Number of People Under 18 Years in Household"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 99) or (x==0)
    @classmethod
    def is_valid_P60(self,x):
        """Number of People 60 Years and Over in Household"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 99) or (x==0)
    @classmethod
    def is_valid_P65(self,x):
        """Number of People 65 Years and Over in Household"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 99) or (x==0)
    @classmethod
    def is_valid_P75(self,x):
        """Number of People 75 Years and Over in Household"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 99) or (x==0)
    @classmethod
    def is_valid_PAC(self,x):
        """Presence and Age of Children Under 18"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_HHSEX(self,x):
        """Sex of Householder"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=28: return False
        if self.is_valid_RTYPE(fields[1]) == False: return False
        if self.is_valid_MAFID(fields[2]) == False: return False
        if self.is_valid_BCUSTATEFP(fields[3]) == False: return False
        if self.is_valid_VERSION(fields[4]) == False: return False
        if self.is_valid_FINAL_POP(fields[5]) == False: return False
        if self.is_valid_HHLDRAGE(fields[6]) == False: return False
        if self.is_valid_HHSPAN(fields[7]) == False: return False
        if self.is_valid_HHLDRACE(fields[8]) == False: return False
        if self.is_valid_HHRACE(fields[9]) == False: return False
        if self.is_valid_TEN(fields[10]) == False: return False
        if self.is_valid_TEN_A(fields[11]) == False: return False
        if self.is_valid_TEN_R(fields[12]) == False: return False
        if self.is_valid_VACS(fields[13]) == False: return False
        if self.is_valid_QGQTYP(fields[14]) == False: return False
        if self.is_valid_GQSEX(fields[15]) == False: return False
        if self.is_valid_OIDTB(fields[16]) == False: return False
        if self.is_valid_HHT(fields[17]) == False: return False
        if self.is_valid_HHT2(fields[18]) == False: return False
        if self.is_valid_CPLT(fields[19]) == False: return False
        if self.is_valid_UPART(fields[20]) == False: return False
        if self.is_valid_MULTG(fields[21]) == False: return False
        if self.is_valid_PAOC(fields[22]) == False: return False
        if self.is_valid_P18(fields[23]) == False: return False
        if self.is_valid_P60(fields[24]) == False: return False
        if self.is_valid_P65(fields[25]) == False: return False
        if self.is_valid_P75(fields[26]) == False: return False
        if self.is_valid_PAC(fields[27]) == False: return False
        if self.is_valid_HHSEX(fields[28]) == False: return False
        return True

class CEF20_UNIT:
    __slots__ = ['RTYPE', 'MAFID', 'BCUSTATEFP', 'VERSION', 'FINAL_POP', 'HHLDRAGE', 'HHSPAN', 'HHLDRACE', 'HHRACE', 'TEN', 'TEN_A', 'TEN_R', 'VACS', 'QGQTYP', 'GQSEX', 'OIDTB', 'HHT', 'HHT2', 'CPLT', 'UPART', 'MULTG', 'PAOC', 'P18', 'P60', 'P65', 'P75', 'PAC', 'HHSEX']
    def __repr__(self):
        return 'CEF20_UNIT<RTYPE:{},MAFID:{},BCUSTATEFP:{},VERSION:{},FINAL_POP:{},HHLDRAGE:{},HHSPAN:{},HHLDRACE:{},HHRACE:{},TEN:{},TEN_A:{},TEN_R:{},VACS:{},QGQTYP:{},GQSEX:{},OIDTB:{},HHT:{},HHT2:{},CPLT:{},UPART:{},MULTG:{},PAOC:{},P18:{},P60:{},P65:{},P75:{},PAC:{},HHSEX:{}>'.format(self.RTYPE,self.MAFID,self.BCUSTATEFP,self.VERSION,self.FINAL_POP,self.HHLDRAGE,self.HHSPAN,self.HHLDRACE,self.HHRACE,self.TEN,self.TEN_A,self.TEN_R,self.VACS,self.QGQTYP,self.GQSEX,self.OIDTB,self.HHT,self.HHT2,self.CPLT,self.UPART,self.MULTG,self.PAOC,self.P18,self.P60,self.P65,self.P75,self.PAC,self.HHSEX)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'CEF20_UNIT'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=28:
            raise ValueError(f'expected 28 fields, found {len(fields)}')
        self.RTYPE           = fields[0]  # Record Type
        self.MAFID           = fields[1]  # (Primary Key) Master Address File ID.  (The unique identifier of Permanent MAFUNIT ID)
        self.BCUSTATEFP      = fields[2]  # FIPS State Code. Basic Collection Unit State Code
        self.VERSION         = fields[3]  # Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)
        self.FINAL_POP       = fields[4]  # Final Population Count
        self.HHLDRAGE        = fields[5]  # Edited Age of Householder
        self.HHSPAN          = fields[6]  # Hispanic Householder
        self.HHLDRACE        = fields[7]  # Edited QRACEX of Householder
        self.HHRACE          = fields[8]  # Edited CENRACE of Householder
        self.TEN             = fields[9]  # Edited Tenure
        self.TEN_A           = fields[10]  # Edited Tenure Based on Age of Householder
        self.TEN_R           = fields[11]  # Edited Tenure Based on Householder Race
        self.VACS            = fields[12]  # Edited Vacancy Status
        self.QGQTYP          = fields[13]  # Edited Group Quarters Type Code
        self.GQSEX           = fields[14]  # GQ Unit Sex Composition Flag (from final edited sex)
        self.OIDTB           = fields[15]  # Tabulation Block OID
        self.HHT             = fields[16]  # Household/Family Type
        self.HHT2            = fields[17]  # Household/Family Type (Includes Cohabiting)
        self.CPLT            = fields[18]  # Couple Type
        self.UPART           = fields[19]  # Presence and Type of Unmarried Partner Household
        self.MULTG           = fields[20]  # Multigenerational Household
        self.PAOC            = fields[21]  # Presence and Age of Own Children Under 18
        self.P18             = fields[22]  # Number of People Under 18 Years in Household
        self.P60             = fields[23]  # Number of People 60 Years and Over in Household
        self.P65             = fields[24]  # Number of People 65 Years and Over in Household
        self.P75             = fields[25]  # Number of People 75 Years and Over in Household
        self.PAC             = fields[26]  # Presence and Age of Children Under 18
        self.HHSEX           = fields[27]  # Sex of Householder

    def parse_column_specified(self,line):
        self.RTYPE           = line[0:1] # Record Type
        self.MAFID           = line[1:10] # (Primary Key) Master Address File ID.  (The unique identifier of Permanent MAFUNIT ID)
        self.BCUSTATEFP      = line[10:12] # FIPS State Code. Basic Collection Unit State Code
        self.VERSION         = line[12:17] # Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)
        self.FINAL_POP       = line[17:22] # Final Population Count
        self.HHLDRAGE        = line[22:25] # Edited Age of Householder
        self.HHSPAN          = line[25:26] # Hispanic Householder
        self.HHLDRACE        = line[26:27] # Edited QRACEX of Householder
        self.HHRACE          = line[27:29] # Edited CENRACE of Householder
        self.TEN             = line[29:30] # Edited Tenure
        self.TEN_A           = line[30:31] # Edited Tenure Based on Age of Householder
        self.TEN_R           = line[31:32] # Edited Tenure Based on Householder Race
        self.VACS            = line[32:33] # Edited Vacancy Status
        self.QGQTYP          = line[33:36] # Edited Group Quarters Type Code
        self.GQSEX           = line[36:37] # GQ Unit Sex Composition Flag (from final edited sex)
        self.OIDTB           = line[37:59] # Tabulation Block OID
        self.HHT             = line[59:60] # Household/Family Type
        self.HHT2            = line[60:62] # Household/Family Type (Includes Cohabiting)
        self.CPLT            = line[62:63] # Couple Type
        self.UPART           = line[63:64] # Presence and Type of Unmarried Partner Household
        self.MULTG           = line[64:65] # Multigenerational Household
        self.PAOC            = line[65:66] # Presence and Age of Own Children Under 18
        self.P18             = line[66:68] # Number of People Under 18 Years in Household
        self.P60             = line[68:70] # Number of People 60 Years and Over in Household
        self.P65             = line[70:72] # Number of People 65 Years and Over in Household
        self.P75             = line[72:74] # Number of People 75 Years and Over in Household
        self.PAC             = line[74:75] # Presence and Age of Children Under 18
        self.HHSEX           = line[75:76] # Sex of Householder

    def validate(self):
        """Return True if the object data validates"""
        if not CEF20_UNIT_validator.is_valid_RTYPE(self.RTYPE): return False
        if not CEF20_UNIT_validator.is_valid_MAFID(self.MAFID): return False
        if not CEF20_UNIT_validator.is_valid_BCUSTATEFP(self.BCUSTATEFP): return False
        if not CEF20_UNIT_validator.is_valid_VERSION(self.VERSION): return False
        if not CEF20_UNIT_validator.is_valid_FINAL_POP(self.FINAL_POP): return False
        if not CEF20_UNIT_validator.is_valid_HHLDRAGE(self.HHLDRAGE): return False
        if not CEF20_UNIT_validator.is_valid_HHSPAN(self.HHSPAN): return False
        if not CEF20_UNIT_validator.is_valid_HHLDRACE(self.HHLDRACE): return False
        if not CEF20_UNIT_validator.is_valid_HHRACE(self.HHRACE): return False
        if not CEF20_UNIT_validator.is_valid_TEN(self.TEN): return False
        if not CEF20_UNIT_validator.is_valid_TEN_A(self.TEN_A): return False
        if not CEF20_UNIT_validator.is_valid_TEN_R(self.TEN_R): return False
        if not CEF20_UNIT_validator.is_valid_VACS(self.VACS): return False
        if not CEF20_UNIT_validator.is_valid_QGQTYP(self.QGQTYP): return False
        if not CEF20_UNIT_validator.is_valid_GQSEX(self.GQSEX): return False
        if not CEF20_UNIT_validator.is_valid_OIDTB(self.OIDTB): return False
        if not CEF20_UNIT_validator.is_valid_HHT(self.HHT): return False
        if not CEF20_UNIT_validator.is_valid_HHT2(self.HHT2): return False
        if not CEF20_UNIT_validator.is_valid_CPLT(self.CPLT): return False
        if not CEF20_UNIT_validator.is_valid_UPART(self.UPART): return False
        if not CEF20_UNIT_validator.is_valid_MULTG(self.MULTG): return False
        if not CEF20_UNIT_validator.is_valid_PAOC(self.PAOC): return False
        if not CEF20_UNIT_validator.is_valid_P18(self.P18): return False
        if not CEF20_UNIT_validator.is_valid_P60(self.P60): return False
        if not CEF20_UNIT_validator.is_valid_P65(self.P65): return False
        if not CEF20_UNIT_validator.is_valid_P75(self.P75): return False
        if not CEF20_UNIT_validator.is_valid_PAC(self.PAC): return False
        if not CEF20_UNIT_validator.is_valid_HHSEX(self.HHSEX): return False
        return True

    def validate_reason(self):
        reason=[]
        if not CEF20_UNIT_validator.is_valid_RTYPE(self.RTYPE): reason.append('RTYPE ('+str(self.RTYPE)+') out of range (4-4, 2-2)')
        if not CEF20_UNIT_validator.is_valid_MAFID(self.MAFID): reason.append('MAFID ('+str(self.MAFID)+') out of range (100000001-899999999)')
        if not CEF20_UNIT_validator.is_valid_BCUSTATEFP(self.BCUSTATEFP): reason.append('BCUSTATEFP ('+str(self.BCUSTATEFP)+') out of range (53-56, 04-06, 15-42, 08-13, 01-02, 72-72, 44-51)')
        if not CEF20_UNIT_validator.is_valid_VERSION(self.VERSION): reason.append('VERSION ('+str(self.VERSION)+') out of range (00000-99999)')
        if not CEF20_UNIT_validator.is_valid_FINAL_POP(self.FINAL_POP): reason.append('FINAL_POP ('+str(self.FINAL_POP)+') out of range (0-99999)')
        if not CEF20_UNIT_validator.is_valid_HHLDRAGE(self.HHLDRAGE): reason.append('HHLDRAGE ('+str(self.HHLDRAGE)+') out of range (15-115)')
        if not CEF20_UNIT_validator.is_valid_HHSPAN(self.HHSPAN): reason.append('HHSPAN ('+str(self.HHSPAN)+') out of range (1-1, 2-2)')
        if not CEF20_UNIT_validator.is_valid_HHLDRACE(self.HHLDRACE): reason.append('HHLDRACE ('+str(self.HHLDRACE)+') out of range (1-1, 6-6, 5-5, 4-4, 2-2, 3-3)')
        if not CEF20_UNIT_validator.is_valid_HHRACE(self.HHRACE): reason.append('HHRACE ('+str(self.HHRACE)+') out of range (11-11, 15-15, 07-07, 08-08, 14-14, 17-17, 25-25, 45-45, 06-06, 18-18, 27-27, 60-60, 48-48, 59-59, 61-61, 63-63, 35-35, 43-43, 03-03, 21-21, 01-01, 22-22, 33-33, 36-36, 40-40, 24-24, 26-26, 38-38, 49-49, 51-51, 52-52, 05-05, 28-28, 29-29, 54-54, 12-12, 19-19, 44-44, 50-50, 58-58, 62-62, 32-32, 47-47, 55-55, 09-09, 16-16, 20-20, 23-23, 31-31, 37-37, 13-13, 41-41, 42-42, 46-46, 56-56, 57-57, 02-02, 30-30, 34-34, 39-39, 04-04, 53-53, 10-10)')
        if not CEF20_UNIT_validator.is_valid_TEN(self.TEN): reason.append('TEN ('+str(self.TEN)+') out of range (1-1, 0-0, 4-4, 2-2, 3-3)')
        if not CEF20_UNIT_validator.is_valid_TEN_A(self.TEN_A): reason.append('TEN_A ('+str(self.TEN_A)+') out of range (1-1, 0-0, 4-4, 2-2, 3-3)')
        if not CEF20_UNIT_validator.is_valid_TEN_R(self.TEN_R): reason.append('TEN_R ('+str(self.TEN_R)+') out of range (1-1, 0-0, 4-4, 2-2, 3-3)')
        if not CEF20_UNIT_validator.is_valid_VACS(self.VACS): reason.append('VACS ('+str(self.VACS)+') out of range (1-1, 0-0, 6-6, 5-5, 4-4, 2-2, 3-3, 7-7)')
        if not CEF20_UNIT_validator.is_valid_QGQTYP(self.QGQTYP): reason.append('QGQTYP ('+str(self.QGQTYP)+') out of range (801-801, 403-403, 404-404, 405-405, 706-706, 904-904, 802-802, 101-101, 202-202, 903-903, 401-401, 201-201, 105-105, 106-106, 601-601, 602-602, 901-901, 402-402, 701-701, 102-102, 104-104, 702-702, 704-704, 900-900, 203-203, 103-103, 501-501, 301-301)')
        if not CEF20_UNIT_validator.is_valid_GQSEX(self.GQSEX): reason.append('GQSEX ('+str(self.GQSEX)+') out of range (3-3, 1-1, 2-2)')
        if not CEF20_UNIT_validator.is_valid_OIDTB(self.OIDTB): reason.append('OIDTB ('+str(self.OIDTB)+') out of range ()')
        if not CEF20_UNIT_validator.is_valid_HHT(self.HHT): reason.append('HHT ('+str(self.HHT)+') out of range (1-1, 0-0, 6-6, 5-5, 4-4, 2-2, 3-3, 7-7)')
        if not CEF20_UNIT_validator.is_valid_HHT2(self.HHT2): reason.append('HHT2 ('+str(self.HHT2)+') out of range (05-05, 11-11, 07-07, 08-08, 09-09, 12-12, 03-03, 06-06, 02-02, 01-01, 00-00, 04-04, 10-10)')
        if not CEF20_UNIT_validator.is_valid_CPLT(self.CPLT): reason.append('CPLT ('+str(self.CPLT)+') out of range (1-1, 0-0, 5-5, 4-4, 2-2, 3-3)')
        if not CEF20_UNIT_validator.is_valid_UPART(self.UPART): reason.append('UPART ('+str(self.UPART)+') out of range (1-1, 0-0, 5-5, 4-4, 2-2, 3-3)')
        if not CEF20_UNIT_validator.is_valid_MULTG(self.MULTG): reason.append('MULTG ('+str(self.MULTG)+') out of range (2-2, 1-1, 0-0)')
        if not CEF20_UNIT_validator.is_valid_PAOC(self.PAOC): reason.append('PAOC ('+str(self.PAOC)+') out of range (1-1, 0-0, 4-4, 2-2, 3-3)')
        if not CEF20_UNIT_validator.is_valid_P18(self.P18): reason.append('P18 ('+str(self.P18)+') out of range (1-99, 0-0)')
        if not CEF20_UNIT_validator.is_valid_P60(self.P60): reason.append('P60 ('+str(self.P60)+') out of range (1-99, 0-0)')
        if not CEF20_UNIT_validator.is_valid_P65(self.P65): reason.append('P65 ('+str(self.P65)+') out of range (1-99, 0-0)')
        if not CEF20_UNIT_validator.is_valid_P75(self.P75): reason.append('P75 ('+str(self.P75)+') out of range (1-99, 0-0)')
        if not CEF20_UNIT_validator.is_valid_PAC(self.PAC): reason.append('PAC ('+str(self.PAC)+') out of range (1-1, 0-0, 4-4, 2-2, 3-3)')
        if not CEF20_UNIT_validator.is_valid_HHSEX(self.HHSEX): reason.append('HHSEX ('+str(self.HHSEX)+') out of range (2-2, 1-1, 0-0)')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            rtype=safe_str(self.RTYPE),
            mafid=safe_int(self.MAFID),
            bcustatefp=safe_str(self.BCUSTATEFP),
            version=safe_int(self.VERSION),
            final_pop=safe_str(self.FINAL_POP),
            hhldrage=safe_str(self.HHLDRAGE),
            hhspan=safe_str(self.HHSPAN),
            hhldrace=safe_str(self.HHLDRACE),
            hhrace=safe_str(self.HHRACE),
            ten=safe_str(self.TEN),
            ten_a=safe_str(self.TEN_A),
            ten_r=safe_str(self.TEN_R),
            vacs=safe_str(self.VACS),
            qgqtyp=safe_str(self.QGQTYP),
            gqsex=safe_str(self.GQSEX),
            oidtb=safe_int(self.OIDTB),
            hht=safe_str(self.HHT),
            hht2=safe_str(self.HHT2),
            cplt=safe_str(self.CPLT),
            upart=safe_str(self.UPART),
            multg=safe_str(self.MULTG),
            paoc=safe_str(self.PAOC),
            p18=safe_int(self.P18),
            p60=safe_int(self.P60),
            p65=safe_int(self.P65),
            p75=safe_int(self.P75),
            pac=safe_str(self.PAC),
            hhsex=safe_str(self.HHSEX),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: CEF20_UNIT = CEF20_UNIT()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: CEF20_UNIT = CEF20_UNIT()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



# Automatically generated on Fri Oct 30 14:06:08 2020 by /mnt/users/will0555/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError) as e:
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError) as e:
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError) as e:
        return None


class CEF20_PER_validator:
    @classmethod
    def is_valid_RTYPE(self,x):
        """Record Type"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_MAFID(self,x):
        """Master Address File ID.  (The unique identifier of Permanent MAFUNIT ID)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (100000001 <= x <= 899999999)
    @classmethod
    def is_valid_CUF_PNC(self,x):
        """The unique identifier of Unique Person Number."""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 99999)
    @classmethod
    def is_valid_BCUSTATEFP(self,x):
        """FIPS State Code. Basic Collection Unit State Code"""
        if x is None or x == "None":
            return False
        return (between('53',x,'56',2)) or (between('04',x,'06',2)) or (between('15',x,'42',2)) or (between('08',x,'13',2)) or (between('01',x,'02',2)) or (leftpad(x,2)==leftpad('72',2)) or (between('44',x,'51',2))
    @classmethod
    def is_valid_VERSION(self,x):
        """Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (00000 <= x <= 99999)
    @classmethod
    def is_valid_QSEX(self,x):
        """Edited Sex"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('2',1))
    @classmethod
    def is_valid_QAGE(self,x):
        """Edited Age"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (0 <= x <= 115)
    @classmethod
    def is_valid_QDB(self,x):
        """Edited date of birth"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (19040402 <= x <= 20200401)
    @classmethod
    def is_valid_QDOB_MONTH(self,x):
        """Edited Month of Birth"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 12)
    @classmethod
    def is_valid_QDOB_DAY(self,x):
        """Edited Day of Birth"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1 <= x <= 31)
    @classmethod
    def is_valid_QDOB_YEAR(self,x):
        """Edited Year of Birth"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1904 <= x <= 2020)
    @classmethod
    def is_valid_QSPAN(self,x):
        """Final Edited Hispanic Origin Variable"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1000 <= x <= 8999) or (x==9950)
    @classmethod
    def is_valid_QSPANX(self,x):
        """Edited Hispanic Origin Group (Allocation use only)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1)) or (leftpad(x,1)==leftpad('7',1))
    @classmethod
    def is_valid_CENHISP(self,x):
        """A recode of the edited Hispanic origin variable (QSPAN) into two values representing Hispanic and not Hispanic"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (x==1) or (x==2)
    @classmethod
    def is_valid_QRACE1(self,x):
        """Edited First Race Variable"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return (1000 <= x <= 8999)
    @classmethod
    def is_valid_QRACE2(self,x):
        """Edited Second Race Variable"""
        if x is None or x == "None":
            return False
        if x == '    ':
            return True
        return True
    @classmethod
    def is_valid_QRACE3(self,x):
        """Edited Third Race Variable"""
        if x is None or x == "None":
            return False
        if x == '    ':
            return True
        return True
    @classmethod
    def is_valid_QRACE4(self,x):
        """Edited Fourth Race Variable"""
        if x is None or x == "None":
            return False
        if x == '    ':
            return True
        return True
    @classmethod
    def is_valid_QRACE5(self,x):
        """Edited Fifth Race Variable"""
        if x is None or x == "None":
            return False
        if x == '    ':
            return True
        return True
    @classmethod
    def is_valid_QRACE6(self,x):
        """Edited Sixth Race Variable"""
        if x is None or x == "None":
            return False
        if x == '    ':
            return True
        return True
    @classmethod
    def is_valid_QRACE7(self,x):
        """Edited Seventh Race Variable"""
        if x is None or x == "None":
            return False
        if x == '    ':
            return True
        return True
    @classmethod
    def is_valid_QRACE8(self,x):
        """Edited Eighth Race Variable"""
        if x is None or x == "None":
            return False
        if x == '    ':
            return True
        return True
    @classmethod
    def is_valid_QRACEX(self,x):
        """Edited Race Group (Allocation use only)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('6',1)) or (leftpad(x,1)==leftpad('5',1)) or (leftpad(x,1)==leftpad('4',1)) or (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('3',1))
    @classmethod
    def is_valid_CENRACE(self,x):
        """A recode of the eight edited race codes (QRACE1-QRACE8) into a single 2-digit code representing all of the possible race categories"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('11',2)) or (leftpad(x,2)==leftpad('15',2)) or (leftpad(x,2)==leftpad('07',2)) or (leftpad(x,2)==leftpad('08',2)) or (leftpad(x,2)==leftpad('14',2)) or (leftpad(x,2)==leftpad('17',2)) or (leftpad(x,2)==leftpad('25',2)) or (leftpad(x,2)==leftpad('45',2)) or (leftpad(x,2)==leftpad('06',2)) or (leftpad(x,2)==leftpad('18',2)) or (leftpad(x,2)==leftpad('27',2)) or (leftpad(x,2)==leftpad('60',2)) or (leftpad(x,2)==leftpad('48',2)) or (leftpad(x,2)==leftpad('59',2)) or (leftpad(x,2)==leftpad('61',2)) or (leftpad(x,2)==leftpad('63',2)) or (leftpad(x,2)==leftpad('35',2)) or (leftpad(x,2)==leftpad('43',2)) or (leftpad(x,2)==leftpad('03',2)) or (leftpad(x,2)==leftpad('21',2)) or (leftpad(x,2)==leftpad('01',2)) or (leftpad(x,2)==leftpad('22',2)) or (leftpad(x,2)==leftpad('33',2)) or (leftpad(x,2)==leftpad('36',2)) or (leftpad(x,2)==leftpad('40',2)) or (leftpad(x,2)==leftpad('24',2)) or (leftpad(x,2)==leftpad('26',2)) or (leftpad(x,2)==leftpad('38',2)) or (leftpad(x,2)==leftpad('49',2)) or (leftpad(x,2)==leftpad('51',2)) or (leftpad(x,2)==leftpad('52',2)) or (leftpad(x,2)==leftpad('05',2)) or (leftpad(x,2)==leftpad('28',2)) or (leftpad(x,2)==leftpad('29',2)) or (leftpad(x,2)==leftpad('54',2)) or (leftpad(x,2)==leftpad('12',2)) or (leftpad(x,2)==leftpad('19',2)) or (leftpad(x,2)==leftpad('44',2)) or (leftpad(x,2)==leftpad('50',2)) or (leftpad(x,2)==leftpad('58',2)) or (leftpad(x,2)==leftpad('62',2)) or (leftpad(x,2)==leftpad('32',2)) or (leftpad(x,2)==leftpad('47',2)) or (leftpad(x,2)==leftpad('55',2)) or (leftpad(x,2)==leftpad('09',2)) or (leftpad(x,2)==leftpad('16',2)) or (leftpad(x,2)==leftpad('20',2)) or (leftpad(x,2)==leftpad('23',2)) or (leftpad(x,2)==leftpad('31',2)) or (leftpad(x,2)==leftpad('37',2)) or (leftpad(x,2)==leftpad('13',2)) or (leftpad(x,2)==leftpad('41',2)) or (leftpad(x,2)==leftpad('42',2)) or (leftpad(x,2)==leftpad('46',2)) or (leftpad(x,2)==leftpad('56',2)) or (leftpad(x,2)==leftpad('57',2)) or (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('30',2)) or (leftpad(x,2)==leftpad('34',2)) or (leftpad(x,2)==leftpad('39',2)) or (leftpad(x,2)==leftpad('04',2)) or (leftpad(x,2)==leftpad('53',2)) or (leftpad(x,2)==leftpad('10',2))
    @classmethod
    def is_valid_RACE2010(self,x):
        """2010 IMPRACE Method:  A recode of the OMB race variables (the non-SOR major race groups)"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('11',2)) or (leftpad(x,2)==leftpad('15',2)) or (leftpad(x,2)==leftpad('07',2)) or (leftpad(x,2)==leftpad('08',2)) or (leftpad(x,2)==leftpad('14',2)) or (leftpad(x,2)==leftpad('17',2)) or (leftpad(x,2)==leftpad('25',2)) or (leftpad(x,2)==leftpad('06',2)) or (leftpad(x,2)==leftpad('18',2)) or (leftpad(x,2)==leftpad('27',2)) or (leftpad(x,2)==leftpad('03',2)) or (leftpad(x,2)==leftpad('21',2)) or (leftpad(x,2)==leftpad('01',2)) or (leftpad(x,2)==leftpad('22',2)) or (leftpad(x,2)==leftpad('24',2)) or (leftpad(x,2)==leftpad('26',2)) or (leftpad(x,2)==leftpad('05',2)) or (leftpad(x,2)==leftpad('28',2)) or (leftpad(x,2)==leftpad('29',2)) or (leftpad(x,2)==leftpad('12',2)) or (leftpad(x,2)==leftpad('19',2)) or (leftpad(x,2)==leftpad('09',2)) or (leftpad(x,2)==leftpad('16',2)) or (leftpad(x,2)==leftpad('20',2)) or (leftpad(x,2)==leftpad('23',2)) or (leftpad(x,2)==leftpad('31',2)) or (leftpad(x,2)==leftpad('13',2)) or (leftpad(x,2)==leftpad('02',2)) or (leftpad(x,2)==leftpad('30',2)) or (leftpad(x,2)==leftpad('04',2)) or (leftpad(x,2)==leftpad('10',2))
    @classmethod
    def is_valid_RELSHIP(self,x):
        """Final Edited Relationship"""
        if x is None or x == "None":
            return False
        return (leftpad(x,2)==leftpad('28',2)) or (leftpad(x,2)==leftpad('29',2)) or (leftpad(x,2)==leftpad('25',2)) or (leftpad(x,2)==leftpad('31',2)) or (leftpad(x,2)==leftpad('23',2)) or (leftpad(x,2)==leftpad('20',2)) or (leftpad(x,2)==leftpad('33',2)) or (leftpad(x,2)==leftpad('35',2)) or (leftpad(x,2)==leftpad('26',2)) or (leftpad(x,2)==leftpad('27',2)) or (leftpad(x,2)==leftpad('32',2)) or (leftpad(x,2)==leftpad('37',2)) or (leftpad(x,2)==leftpad('38',2)) or (leftpad(x,2)==leftpad('30',2)) or (leftpad(x,2)==leftpad('34',2)) or (leftpad(x,2)==leftpad('36',2)) or (leftpad(x,2)==leftpad('21',2)) or (leftpad(x,2)==leftpad('24',2)) or (leftpad(x,2)==leftpad('22',2))
    @classmethod
    def is_valid_QGQTYP(self,x):
        """Edited Group Quarters Type Code"""
        if x is None or x == "None":
            return False
        if x == '   ':
            return True
        return (leftpad(x,3)==leftpad('801',3)) or (leftpad(x,3)==leftpad('403',3)) or (leftpad(x,3)==leftpad('404',3)) or (leftpad(x,3)==leftpad('405',3)) or (leftpad(x,3)==leftpad('706',3)) or (leftpad(x,3)==leftpad('904',3)) or (leftpad(x,3)==leftpad('802',3)) or (leftpad(x,3)==leftpad('101',3)) or (leftpad(x,3)==leftpad('202',3)) or (leftpad(x,3)==leftpad('903',3)) or (leftpad(x,3)==leftpad('401',3)) or (leftpad(x,3)==leftpad('201',3)) or (leftpad(x,3)==leftpad('105',3)) or (leftpad(x,3)==leftpad('106',3)) or (leftpad(x,3)==leftpad('601',3)) or (leftpad(x,3)==leftpad('602',3)) or (leftpad(x,3)==leftpad('901',3)) or (leftpad(x,3)==leftpad('402',3)) or (leftpad(x,3)==leftpad('701',3)) or (leftpad(x,3)==leftpad('102',3)) or (leftpad(x,3)==leftpad('104',3)) or (leftpad(x,3)==leftpad('702',3)) or (leftpad(x,3)==leftpad('704',3)) or (leftpad(x,3)==leftpad('900',3)) or (leftpad(x,3)==leftpad('203',3)) or (leftpad(x,3)==leftpad('103',3)) or (leftpad(x,3)==leftpad('501',3)) or (leftpad(x,3)==leftpad('301',3))
    @classmethod
    def is_valid_LIVE_ALONE(self,x):
        """Person Living Alone"""
        if x is None or x == "None":
            return False
        return (leftpad(x,1)==leftpad('2',1)) or (leftpad(x,1)==leftpad('1',1)) or (leftpad(x,1)==leftpad('0',1))

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=28: return False
        if self.is_valid_RTYPE(fields[1]) == False: return False
        if self.is_valid_MAFID(fields[2]) == False: return False
        if self.is_valid_CUF_PNC(fields[3]) == False: return False
        if self.is_valid_BCUSTATEFP(fields[4]) == False: return False
        if self.is_valid_VERSION(fields[5]) == False: return False
        if self.is_valid_QSEX(fields[6]) == False: return False
        if self.is_valid_QAGE(fields[7]) == False: return False
        if self.is_valid_QDB(fields[8]) == False: return False
        if self.is_valid_QDOB_MONTH(fields[9]) == False: return False
        if self.is_valid_QDOB_DAY(fields[10]) == False: return False
        if self.is_valid_QDOB_YEAR(fields[11]) == False: return False
        if self.is_valid_QSPAN(fields[12]) == False: return False
        if self.is_valid_QSPANX(fields[13]) == False: return False
        if self.is_valid_CENHISP(fields[14]) == False: return False
        if self.is_valid_QRACE1(fields[15]) == False: return False
        if self.is_valid_QRACE2(fields[16]) == False: return False
        if self.is_valid_QRACE3(fields[17]) == False: return False
        if self.is_valid_QRACE4(fields[18]) == False: return False
        if self.is_valid_QRACE5(fields[19]) == False: return False
        if self.is_valid_QRACE6(fields[20]) == False: return False
        if self.is_valid_QRACE7(fields[21]) == False: return False
        if self.is_valid_QRACE8(fields[22]) == False: return False
        if self.is_valid_QRACEX(fields[23]) == False: return False
        if self.is_valid_CENRACE(fields[24]) == False: return False
        if self.is_valid_RACE2010(fields[25]) == False: return False
        if self.is_valid_RELSHIP(fields[26]) == False: return False
        if self.is_valid_QGQTYP(fields[27]) == False: return False
        if self.is_valid_LIVE_ALONE(fields[28]) == False: return False
        return True

class CEF20_PER:
    __slots__ = ['RTYPE', 'MAFID', 'CUF_PNC', 'BCUSTATEFP', 'VERSION', 'QSEX', 'QAGE', 'QDB', 'QDOB_MONTH', 'QDOB_DAY', 'QDOB_YEAR', 'QSPAN', 'QSPANX', 'CENHISP', 'QRACE1', 'QRACE2', 'QRACE3', 'QRACE4', 'QRACE5', 'QRACE6', 'QRACE7', 'QRACE8', 'QRACEX', 'CENRACE', 'RACE2010', 'RELSHIP', 'QGQTYP', 'LIVE_ALONE']
    def __repr__(self):
        return 'CEF20_PER<RTYPE:{},MAFID:{},CUF_PNC:{},BCUSTATEFP:{},VERSION:{},QSEX:{},QAGE:{},QDB:{},QDOB_MONTH:{},QDOB_DAY:{},QDOB_YEAR:{},QSPAN:{},QSPANX:{},CENHISP:{},QRACE1:{},QRACE2:{},QRACE3:{},QRACE4:{},QRACE5:{},QRACE6:{},QRACE7:{},QRACE8:{},QRACEX:{},CENRACE:{},RACE2010:{},RELSHIP:{},QGQTYP:{},LIVE_ALONE:{}>'.format(self.RTYPE,self.MAFID,self.CUF_PNC,self.BCUSTATEFP,self.VERSION,self.QSEX,self.QAGE,self.QDB,self.QDOB_MONTH,self.QDOB_DAY,self.QDOB_YEAR,self.QSPAN,self.QSPANX,self.CENHISP,self.QRACE1,self.QRACE2,self.QRACE3,self.QRACE4,self.QRACE5,self.QRACE6,self.QRACE7,self.QRACE8,self.QRACEX,self.CENRACE,self.RACE2010,self.RELSHIP,self.QGQTYP,self.LIVE_ALONE)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'CEF20_PER'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=28:
            raise ValueError(f'expected 28 fields, found {len(fields)}')
        self.RTYPE           = fields[0]  # Record Type
        self.MAFID           = fields[1]  # Master Address File ID.  (The unique identifier of Permanent MAFUNIT ID)
        self.CUF_PNC         = fields[2]  # The unique identifier of Unique Person Number.
        self.BCUSTATEFP      = fields[3]  # FIPS State Code. Basic Collection Unit State Code
        self.VERSION         = fields[4]  # Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)
        self.QSEX            = fields[5]  # Edited Sex
        self.QAGE            = fields[6]  # Edited Age
        self.QDB             = fields[7]  # Edited date of birth
        self.QDOB_MONTH      = fields[8]  # Edited Month of Birth
        self.QDOB_DAY        = fields[9]  # Edited Day of Birth
        self.QDOB_YEAR       = fields[10]  # Edited Year of Birth
        self.QSPAN           = fields[11]  # Final Edited Hispanic Origin Variable
        self.QSPANX          = fields[12]  # Edited Hispanic Origin Group (Allocation use only)
        self.CENHISP         = fields[13]  # A recode of the edited Hispanic origin variable (QSPAN) into two values representing Hispanic and not Hispanic
        self.QRACE1          = fields[14]  # Edited First Race Variable
        self.QRACE2          = fields[15]  # Edited Second Race Variable
        self.QRACE3          = fields[16]  # Edited Third Race Variable
        self.QRACE4          = fields[17]  # Edited Fourth Race Variable
        self.QRACE5          = fields[18]  # Edited Fifth Race Variable
        self.QRACE6          = fields[19]  # Edited Sixth Race Variable
        self.QRACE7          = fields[20]  # Edited Seventh Race Variable
        self.QRACE8          = fields[21]  # Edited Eighth Race Variable
        self.QRACEX          = fields[22]  # Edited Race Group (Allocation use only)
        self.CENRACE         = fields[23]  # A recode of the eight edited race codes (QRACE1-QRACE8) into a single 2-digit code representing all of the possible race categories
        self.RACE2010        = fields[24]  # 2010 IMPRACE Method:  A recode of the OMB race variables (the non-SOR major race groups)
        self.RELSHIP         = fields[25]  # Final Edited Relationship
        self.QGQTYP          = fields[26]  # Edited Group Quarters Type Code
        self.LIVE_ALONE      = fields[27]  # Person Living Alone

    def parse_column_specified(self,line):
        self.RTYPE           = line[0:1] # Record Type
        self.MAFID           = line[1:10] # Master Address File ID.  (The unique identifier of Permanent MAFUNIT ID)
        self.CUF_PNC         = line[10:15] # The unique identifier of Unique Person Number.
        self.BCUSTATEFP      = line[15:17] # FIPS State Code. Basic Collection Unit State Code
        self.VERSION         = line[17:22] # Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)
        self.QSEX            = line[22:23] # Edited Sex
        self.QAGE            = line[23:26] # Edited Age
        self.QDB             = line[26:34] # Edited date of birth
        self.QDOB_MONTH      = line[34:36] # Edited Month of Birth
        self.QDOB_DAY        = line[36:38] # Edited Day of Birth
        self.QDOB_YEAR       = line[38:42] # Edited Year of Birth
        self.QSPAN           = line[42:46] # Final Edited Hispanic Origin Variable
        self.QSPANX          = line[46:47] # Edited Hispanic Origin Group (Allocation use only)
        self.CENHISP         = line[47:48] # A recode of the edited Hispanic origin variable (QSPAN) into two values representing Hispanic and not Hispanic
        self.QRACE1          = line[48:52] # Edited First Race Variable
        self.QRACE2          = line[52:56] # Edited Second Race Variable
        self.QRACE3          = line[56:60] # Edited Third Race Variable
        self.QRACE4          = line[60:64] # Edited Fourth Race Variable
        self.QRACE5          = line[64:68] # Edited Fifth Race Variable
        self.QRACE6          = line[68:72] # Edited Sixth Race Variable
        self.QRACE7          = line[72:76] # Edited Seventh Race Variable
        self.QRACE8          = line[76:80] # Edited Eighth Race Variable
        self.QRACEX          = line[80:81] # Edited Race Group (Allocation use only)
        self.CENRACE         = line[81:83] # A recode of the eight edited race codes (QRACE1-QRACE8) into a single 2-digit code representing all of the possible race categories
        self.RACE2010        = line[83:85] # 2010 IMPRACE Method:  A recode of the OMB race variables (the non-SOR major race groups)
        self.RELSHIP         = line[85:87] # Final Edited Relationship
        self.QGQTYP          = line[87:90] # Edited Group Quarters Type Code
        self.LIVE_ALONE      = line[90:91] # Person Living Alone

    def validate(self):
        """Return True if the object data validates"""
        if not CEF20_PER_validator.is_valid_RTYPE(self.RTYPE): return False
        if not CEF20_PER_validator.is_valid_MAFID(self.MAFID): return False
        if not CEF20_PER_validator.is_valid_CUF_PNC(self.CUF_PNC): return False
        if not CEF20_PER_validator.is_valid_BCUSTATEFP(self.BCUSTATEFP): return False
        if not CEF20_PER_validator.is_valid_VERSION(self.VERSION): return False
        if not CEF20_PER_validator.is_valid_QSEX(self.QSEX): return False
        if not CEF20_PER_validator.is_valid_QAGE(self.QAGE): return False
        if not CEF20_PER_validator.is_valid_QDB(self.QDB): return False
        if not CEF20_PER_validator.is_valid_QDOB_MONTH(self.QDOB_MONTH): return False
        if not CEF20_PER_validator.is_valid_QDOB_DAY(self.QDOB_DAY): return False
        if not CEF20_PER_validator.is_valid_QDOB_YEAR(self.QDOB_YEAR): return False
        if not CEF20_PER_validator.is_valid_QSPAN(self.QSPAN): return False
        if not CEF20_PER_validator.is_valid_QSPANX(self.QSPANX): return False
        if not CEF20_PER_validator.is_valid_CENHISP(self.CENHISP): return False
        if not CEF20_PER_validator.is_valid_QRACE1(self.QRACE1): return False
        if not CEF20_PER_validator.is_valid_QRACE2(self.QRACE2): return False
        if not CEF20_PER_validator.is_valid_QRACE3(self.QRACE3): return False
        if not CEF20_PER_validator.is_valid_QRACE4(self.QRACE4): return False
        if not CEF20_PER_validator.is_valid_QRACE5(self.QRACE5): return False
        if not CEF20_PER_validator.is_valid_QRACE6(self.QRACE6): return False
        if not CEF20_PER_validator.is_valid_QRACE7(self.QRACE7): return False
        if not CEF20_PER_validator.is_valid_QRACE8(self.QRACE8): return False
        if not CEF20_PER_validator.is_valid_QRACEX(self.QRACEX): return False
        if not CEF20_PER_validator.is_valid_CENRACE(self.CENRACE): return False
        if not CEF20_PER_validator.is_valid_RACE2010(self.RACE2010): return False
        if not CEF20_PER_validator.is_valid_RELSHIP(self.RELSHIP): return False
        if not CEF20_PER_validator.is_valid_QGQTYP(self.QGQTYP): return False
        if not CEF20_PER_validator.is_valid_LIVE_ALONE(self.LIVE_ALONE): return False
        return True

    def validate_reason(self):
        reason=[]
        if not CEF20_PER_validator.is_valid_RTYPE(self.RTYPE): reason.append('RTYPE ('+str(self.RTYPE)+') out of range (5-5, 3-3)')
        if not CEF20_PER_validator.is_valid_MAFID(self.MAFID): reason.append('MAFID ('+str(self.MAFID)+') out of range (100000001-899999999)')
        if not CEF20_PER_validator.is_valid_CUF_PNC(self.CUF_PNC): reason.append('CUF_PNC ('+str(self.CUF_PNC)+') out of range (1-99999)')
        if not CEF20_PER_validator.is_valid_BCUSTATEFP(self.BCUSTATEFP): reason.append('BCUSTATEFP ('+str(self.BCUSTATEFP)+') out of range (53-56, 04-06, 15-42, 08-13, 01-02, 72-72, 44-51)')
        if not CEF20_PER_validator.is_valid_VERSION(self.VERSION): reason.append('VERSION ('+str(self.VERSION)+') out of range (00000-99999)')
        if not CEF20_PER_validator.is_valid_QSEX(self.QSEX): reason.append('QSEX ('+str(self.QSEX)+') out of range (1-1, 2-2)')
        if not CEF20_PER_validator.is_valid_QAGE(self.QAGE): reason.append('QAGE ('+str(self.QAGE)+') out of range (0-115)')
        if not CEF20_PER_validator.is_valid_QDB(self.QDB): reason.append('QDB ('+str(self.QDB)+') out of range (19040402-20200401)')
        if not CEF20_PER_validator.is_valid_QDOB_MONTH(self.QDOB_MONTH): reason.append('QDOB_MONTH ('+str(self.QDOB_MONTH)+') out of range (1-12)')
        if not CEF20_PER_validator.is_valid_QDOB_DAY(self.QDOB_DAY): reason.append('QDOB_DAY ('+str(self.QDOB_DAY)+') out of range (1-31)')
        if not CEF20_PER_validator.is_valid_QDOB_YEAR(self.QDOB_YEAR): reason.append('QDOB_YEAR ('+str(self.QDOB_YEAR)+') out of range (1904-2020)')
        if not CEF20_PER_validator.is_valid_QSPAN(self.QSPAN): reason.append('QSPAN ('+str(self.QSPAN)+') out of range (1000-8999, 9950-9950)')
        if not CEF20_PER_validator.is_valid_QSPANX(self.QSPANX): reason.append('QSPANX ('+str(self.QSPANX)+') out of range (1-1, 6-6, 5-5, 4-4, 2-2, 3-3, 7-7)')
        if not CEF20_PER_validator.is_valid_CENHISP(self.CENHISP): reason.append('CENHISP ('+str(self.CENHISP)+') out of range (1-1, 2-2)')
        if not CEF20_PER_validator.is_valid_QRACE1(self.QRACE1): reason.append('QRACE1 ('+str(self.QRACE1)+') out of range (1000-8999)')
        if not CEF20_PER_validator.is_valid_QRACE2(self.QRACE2): reason.append('QRACE2 ('+str(self.QRACE2)+') out of range ()')
        if not CEF20_PER_validator.is_valid_QRACE3(self.QRACE3): reason.append('QRACE3 ('+str(self.QRACE3)+') out of range ()')
        if not CEF20_PER_validator.is_valid_QRACE4(self.QRACE4): reason.append('QRACE4 ('+str(self.QRACE4)+') out of range ()')
        if not CEF20_PER_validator.is_valid_QRACE5(self.QRACE5): reason.append('QRACE5 ('+str(self.QRACE5)+') out of range ()')
        if not CEF20_PER_validator.is_valid_QRACE6(self.QRACE6): reason.append('QRACE6 ('+str(self.QRACE6)+') out of range ()')
        if not CEF20_PER_validator.is_valid_QRACE7(self.QRACE7): reason.append('QRACE7 ('+str(self.QRACE7)+') out of range ()')
        if not CEF20_PER_validator.is_valid_QRACE8(self.QRACE8): reason.append('QRACE8 ('+str(self.QRACE8)+') out of range ()')
        if not CEF20_PER_validator.is_valid_QRACEX(self.QRACEX): reason.append('QRACEX ('+str(self.QRACEX)+') out of range (1-1, 6-6, 5-5, 4-4, 2-2, 3-3)')
        if not CEF20_PER_validator.is_valid_CENRACE(self.CENRACE): reason.append('CENRACE ('+str(self.CENRACE)+') out of range (11-11, 15-15, 07-07, 08-08, 14-14, 17-17, 25-25, 45-45, 06-06, 18-18, 27-27, 60-60, 48-48, 59-59, 61-61, 63-63, 35-35, 43-43, 03-03, 21-21, 01-01, 22-22, 33-33, 36-36, 40-40, 24-24, 26-26, 38-38, 49-49, 51-51, 52-52, 05-05, 28-28, 29-29, 54-54, 12-12, 19-19, 44-44, 50-50, 58-58, 62-62, 32-32, 47-47, 55-55, 09-09, 16-16, 20-20, 23-23, 31-31, 37-37, 13-13, 41-41, 42-42, 46-46, 56-56, 57-57, 02-02, 30-30, 34-34, 39-39, 04-04, 53-53, 10-10)')
        if not CEF20_PER_validator.is_valid_RACE2010(self.RACE2010): reason.append('RACE2010 ('+str(self.RACE2010)+') out of range (11-11, 15-15, 07-07, 08-08, 14-14, 17-17, 25-25, 06-06, 18-18, 27-27, 03-03, 21-21, 01-01, 22-22, 24-24, 26-26, 05-05, 28-28, 29-29, 12-12, 19-19, 09-09, 16-16, 20-20, 23-23, 31-31, 13-13, 02-02, 30-30, 04-04, 10-10)')
        if not CEF20_PER_validator.is_valid_RELSHIP(self.RELSHIP): reason.append('RELSHIP ('+str(self.RELSHIP)+') out of range (28-28, 29-29, 25-25, 31-31, 23-23, 20-20, 33-33, 35-35, 26-26, 27-27, 32-32, 37-37, 38-38, 30-30, 34-34, 36-36, 21-21, 24-24, 22-22)')
        if not CEF20_PER_validator.is_valid_QGQTYP(self.QGQTYP): reason.append('QGQTYP ('+str(self.QGQTYP)+') out of range (801-801, 403-403, 404-404, 405-405, 706-706, 904-904, 802-802, 101-101, 202-202, 903-903, 401-401, 201-201, 105-105, 106-106, 601-601, 602-602, 901-901, 402-402, 701-701, 102-102, 104-104, 702-702, 704-704, 900-900, 203-203, 103-103, 501-501, 301-301)')
        if not CEF20_PER_validator.is_valid_LIVE_ALONE(self.LIVE_ALONE): reason.append('LIVE_ALONE ('+str(self.LIVE_ALONE)+') out of range (2-2, 1-1, 0-0)')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            rtype=safe_str(self.RTYPE),
            mafid=safe_int(self.MAFID),
            cuf_pnc=safe_int(self.CUF_PNC),
            bcustatefp=safe_str(self.BCUSTATEFP),
            version=safe_int(self.VERSION),
            qsex=safe_str(self.QSEX),
            qage=safe_int(self.QAGE),
            qdb=safe_int(self.QDB),
            qdob_month=safe_int(self.QDOB_MONTH),
            qdob_day=safe_int(self.QDOB_DAY),
            qdob_year=safe_int(self.QDOB_YEAR),
            qspan=safe_int(self.QSPAN),
            qspanx=safe_str(self.QSPANX),
            cenhisp=safe_int(self.CENHISP),
            qrace1=safe_int(self.QRACE1),
            qrace2=safe_str(self.QRACE2),
            qrace3=safe_str(self.QRACE3),
            qrace4=safe_str(self.QRACE4),
            qrace5=safe_str(self.QRACE5),
            qrace6=safe_str(self.QRACE6),
            qrace7=safe_str(self.QRACE7),
            qrace8=safe_str(self.QRACE8),
            qracex=safe_str(self.QRACEX),
            cenrace=safe_str(self.CENRACE),
            race2010=safe_str(self.RACE2010),
            relship=safe_str(self.RELSHIP),
            qgqtyp=safe_str(self.QGQTYP),
            live_alone=safe_str(self.LIVE_ALONE),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: CEF20_PER = CEF20_PER()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: CEF20_PER = CEF20_PER()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



# Automatically generated on Fri Oct 30 14:06:08 2020 by /mnt/users/will0555/new-das-vm/das-vm-config/das_decennial/das_framework/ctools/schema/table.py

def leftpad(x,width):
    return ' '*(width-len(str(x)))+str(x)

def between(a,b,c,width):
    if len(b) > width:
        return False
    if '.' in a or '.' in b or '.' in c:
        try:
            return float(a) <= float(b) <= float(c)
        except ValueError:
            pass  # tries to return a float but might have weird input like 1.1.0 which will be compared traditionally instead
    b = b.replace(' ', '0')
    return leftpad(a,width) <= leftpad(b,width) <= leftpad(c,width)


def safe_int(i):
    try:
        return int(i)
    except (TypeError, ValueError) as e:
        return None

def safe_float(i):
    try:
        return float(i)
    except (TypeError, ValueError) as e:
        return None

def safe_str(i):
    try:
        return str(i)
    except (TypeError, ValueError) as e:
        return None


class CEF20_CNT_validator:
    @classmethod
    def is_valid_BCUSTATEFP(self,x):
        """FIPS State Code. Basic Collection Unit State Code (The legal values for this file are 01-02, 04-06, 08-13, 15-42,  44-51, 53-56, and 72.)"""
        if x is None or x == "None":
            return False
        return True
    @classmethod
    def is_valid_VERSION(self,x):
        """Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_COUNT_UNIT(self,x):
        """Count of units in the BCUSTATEFP"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_COUNT_UNIT_HU(self,x):
        """Count of Housing Units in the BCUSTATEFP"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_COUNT_UNIT_GQ(self,x):
        """Count of Group Quarters in the BCUSTATEFP"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_COUNT_PER(self,x):
        """Count of persons in the BCUSTATEFP"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_COUNT_PER_HU(self,x):
        """Count of Housing Unit persons in the BCUSTATEFP"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True
    @classmethod
    def is_valid_COUNT_PER_GQ(self,x):
        """Count of Group Quarters persons in the BCUSTATEFP"""
        if x is None or x == "None":
            return False
        x = str(x).strip()
        try:
            x = int(x)
        except ValueError:
            return False
        return True

    @classmethod
    def validate_pipe_delimited(self,x):
        fields = x.split('|')
        if len(fields)!=8: return False
        if self.is_valid_BCUSTATEFP(fields[1]) == False: return False
        if self.is_valid_VERSION(fields[2]) == False: return False
        if self.is_valid_COUNT_UNIT(fields[3]) == False: return False
        if self.is_valid_COUNT_UNIT_HU(fields[4]) == False: return False
        if self.is_valid_COUNT_UNIT_GQ(fields[5]) == False: return False
        if self.is_valid_COUNT_PER(fields[6]) == False: return False
        if self.is_valid_COUNT_PER_HU(fields[7]) == False: return False
        if self.is_valid_COUNT_PER_GQ(fields[8]) == False: return False
        return True

class CEF20_CNT:
    __slots__ = ['BCUSTATEFP', 'VERSION', 'COUNT_UNIT', 'COUNT_UNIT_HU', 'COUNT_UNIT_GQ', 'COUNT_PER', 'COUNT_PER_HU', 'COUNT_PER_GQ']
    def __repr__(self):
        return 'CEF20_CNT<BCUSTATEFP:{},VERSION:{},COUNT_UNIT:{},COUNT_UNIT_HU:{},COUNT_UNIT_GQ:{},COUNT_PER:{},COUNT_PER_HU:{},COUNT_PER_GQ:{}>'.format(self.BCUSTATEFP,self.VERSION,self.COUNT_UNIT,self.COUNT_UNIT_HU,self.COUNT_UNIT_GQ,self.COUNT_PER,self.COUNT_PER_HU,self.COUNT_PER_GQ)
    def __init__(self,line=None):
        if line:
            if '|' in line:
                self.parse_pipe_delimited(line)
            else:
                self.parse_column_specified(line)
    @classmethod
    def name(self):
        return 'CEF20_CNT'

    def parse_pipe_delimited(self,line):
        fields = line.split('|')
        if len(fields)!=8:
            raise ValueError(f'expected 8 fields, found {len(fields)}')
        self.BCUSTATEFP      = fields[0]  # FIPS State Code. Basic Collection Unit State Code (The legal values for this file are 01-02, 04-06, 08-13, 15-42,  44-51, 53-56, and 72.)
        self.VERSION         = fields[1]  # Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)
        self.COUNT_UNIT      = fields[2]  # Count of units in the BCUSTATEFP
        self.COUNT_UNIT_HU   = fields[3]  # Count of Housing Units in the BCUSTATEFP
        self.COUNT_UNIT_GQ   = fields[4]  # Count of Group Quarters in the BCUSTATEFP
        self.COUNT_PER       = fields[5]  # Count of persons in the BCUSTATEFP
        self.COUNT_PER_HU    = fields[6]  # Count of Housing Unit persons in the BCUSTATEFP
        self.COUNT_PER_GQ    = fields[7]  # Count of Group Quarters persons in the BCUSTATEFP

    def parse_column_specified(self,line):
        self.BCUSTATEFP      = line[0:2] # FIPS State Code. Basic Collection Unit State Code (The legal values for this file are 01-02, 04-06, 08-13, 15-42,  44-51, 53-56, and 72.)
        self.VERSION         = line[2:7] # Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)
        self.COUNT_UNIT      = line[7:17] # Count of units in the BCUSTATEFP
        self.COUNT_UNIT_HU   = line[17:27] # Count of Housing Units in the BCUSTATEFP
        self.COUNT_UNIT_GQ   = line[27:37] # Count of Group Quarters in the BCUSTATEFP
        self.COUNT_PER       = line[37:47] # Count of persons in the BCUSTATEFP
        self.COUNT_PER_HU    = line[47:57] # Count of Housing Unit persons in the BCUSTATEFP
        self.COUNT_PER_GQ    = line[57:67] # Count of Group Quarters persons in the BCUSTATEFP

    def validate(self):
        """Return True if the object data validates"""
        if not CEF20_CNT_validator.is_valid_BCUSTATEFP(self.BCUSTATEFP): return False
        if not CEF20_CNT_validator.is_valid_VERSION(self.VERSION): return False
        if not CEF20_CNT_validator.is_valid_COUNT_UNIT(self.COUNT_UNIT): return False
        if not CEF20_CNT_validator.is_valid_COUNT_UNIT_HU(self.COUNT_UNIT_HU): return False
        if not CEF20_CNT_validator.is_valid_COUNT_UNIT_GQ(self.COUNT_UNIT_GQ): return False
        if not CEF20_CNT_validator.is_valid_COUNT_PER(self.COUNT_PER): return False
        if not CEF20_CNT_validator.is_valid_COUNT_PER_HU(self.COUNT_PER_HU): return False
        if not CEF20_CNT_validator.is_valid_COUNT_PER_GQ(self.COUNT_PER_GQ): return False
        return True

    def validate_reason(self):
        reason=[]
        if not CEF20_CNT_validator.is_valid_BCUSTATEFP(self.BCUSTATEFP): reason.append('BCUSTATEFP ('+str(self.BCUSTATEFP)+') out of range ()')
        if not CEF20_CNT_validator.is_valid_VERSION(self.VERSION): reason.append('VERSION ('+str(self.VERSION)+') out of range ()')
        if not CEF20_CNT_validator.is_valid_COUNT_UNIT(self.COUNT_UNIT): reason.append('COUNT_UNIT ('+str(self.COUNT_UNIT)+') out of range ()')
        if not CEF20_CNT_validator.is_valid_COUNT_UNIT_HU(self.COUNT_UNIT_HU): reason.append('COUNT_UNIT_HU ('+str(self.COUNT_UNIT_HU)+') out of range ()')
        if not CEF20_CNT_validator.is_valid_COUNT_UNIT_GQ(self.COUNT_UNIT_GQ): reason.append('COUNT_UNIT_GQ ('+str(self.COUNT_UNIT_GQ)+') out of range ()')
        if not CEF20_CNT_validator.is_valid_COUNT_PER(self.COUNT_PER): reason.append('COUNT_PER ('+str(self.COUNT_PER)+') out of range ()')
        if not CEF20_CNT_validator.is_valid_COUNT_PER_HU(self.COUNT_PER_HU): reason.append('COUNT_PER_HU ('+str(self.COUNT_PER_HU)+') out of range ()')
        if not CEF20_CNT_validator.is_valid_COUNT_PER_GQ(self.COUNT_PER_GQ): reason.append('COUNT_PER_GQ ('+str(self.COUNT_PER_GQ)+') out of range ()')
        return ', '.join(reason)

    def SparkSQLRow(self):
        """Return a SparkSQL Row object for this object."""
        from pyspark.sql import Row
        return Row(
            bcustatefp=safe_str(self.BCUSTATEFP),
            version=safe_int(self.VERSION),
            count_unit=safe_int(self.COUNT_UNIT),
            count_unit_hu=safe_int(self.COUNT_UNIT_HU),
            count_unit_gq=safe_int(self.COUNT_UNIT_GQ),
            count_per=safe_int(self.COUNT_PER),
            count_per_hu=safe_int(self.COUNT_PER_HU),
            count_per_gq=safe_int(self.COUNT_PER_GQ),
        )


    @staticmethod
    def parse_line(line):
        # Read a line and return it as a dictionary.
        inst: CEF20_CNT = CEF20_CNT()
        inst.parse_column_specified(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row

    @staticmethod
    def parse_piped_line(line):
        # Read a pipe-delimited line and return it as a dictionary.
        inst: CEF20_CNT = CEF20_CNT()
        inst.parse_pipe_delimited(line)
        assert inst.validate(), f'A line is invalid!! line: {line}, validate_reason: {inst.validate_reason()}'
        row = inst.SparkSQLRow()
        return row



SPEC_CLASS_OBJECTS = [CEF20_UNIT(),CEF20_PER(),CEF20_CNT()]
null = None
SPEC_DICT = {"tables": {"CEF20_UNIT": {"name": "CEF20_UNIT", "variables": [{"name": "RTYPE", "vtype": "VARCHAR", "position": 1, "desc": "Record Type", "column": 0, "width": 1, "ranges": [{"a": "4", "b": "4"}, {"a": "2", "b": "2"}]}, {"name": "MAFID", "vtype": "NUMBER", "position": 2, "desc": "(Primary Key) Master Address File ID.  (The unique identifier of Permanent MAFUNIT ID)", "column": 1, "width": 9, "ranges": [{"a": "100000001", "b": "899999999"}]}, {"name": "BCUSTATEFP", "vtype": "VARCHAR", "position": "=A6+1", "desc": "FIPS State Code. Basic Collection Unit State Code", "column": 10, "width": 2, "ranges": [{"a": "53", "b": "56"}, {"a": "04", "b": "06"}, {"a": "15", "b": "42"}, {"a": "08", "b": "13"}, {"a": "01", "b": "02"}, {"a": "72", "b": "72"}, {"a": "44", "b": "51"}]}, {"name": "VERSION", "vtype": "NUMBER", "position": "=A7+1", "desc": "Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)", "column": 12, "width": 5, "ranges": [{"a": "00000", "b": "99999"}]}, {"name": "FINAL_POP", "vtype": "VARCHAR", "position": "=A8+1", "desc": "Final Population Count", "column": 17, "width": 5, "ranges": [{"a": "0", "b": "99999"}]}, {"name": "HHLDRAGE", "vtype": "NUMBER", "position": "=A9+1", "desc": "Edited Age of Householder", "column": 22, "width": 3, "ranges": [{"a": "15", "b": "115"}]}, {"name": "HHSPAN", "vtype": "NUMBER", "position": "=A10+1", "desc": "Hispanic Householder", "column": 25, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "2", "b": "2"}]}, {"name": "HHLDRACE", "vtype": "VARCHAR", "position": "=A12+1", "desc": "Edited QRACEX of Householder", "column": 26, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "6", "b": "6"}, {"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "HHRACE", "vtype": "VARCHAR", "position": "=A15+1", "desc": "Edited CENRACE of Householder", "column": 27, "width": 2, "ranges": [{"a": "11", "b": "11"}, {"a": "15", "b": "15"}, {"a": "07", "b": "07"}, {"a": "08", "b": "08"}, {"a": "14", "b": "14"}, {"a": "17", "b": "17"}, {"a": "25", "b": "25"}, {"a": "45", "b": "45"}, {"a": "06", "b": "06"}, {"a": "18", "b": "18"}, {"a": "27", "b": "27"}, {"a": "60", "b": "60"}, {"a": "48", "b": "48"}, {"a": "59", "b": "59"}, {"a": "61", "b": "61"}, {"a": "63", "b": "63"}, {"a": "35", "b": "35"}, {"a": "43", "b": "43"}, {"a": "03", "b": "03"}, {"a": "21", "b": "21"}, {"a": "01", "b": "01"}, {"a": "22", "b": "22"}, {"a": "33", "b": "33"}, {"a": "36", "b": "36"}, {"a": "40", "b": "40"}, {"a": "24", "b": "24"}, {"a": "26", "b": "26"}, {"a": "38", "b": "38"}, {"a": "49", "b": "49"}, {"a": "51", "b": "51"}, {"a": "52", "b": "52"}, {"a": "05", "b": "05"}, {"a": "28", "b": "28"}, {"a": "29", "b": "29"}, {"a": "54", "b": "54"}, {"a": "12", "b": "12"}, {"a": "19", "b": "19"}, {"a": "44", "b": "44"}, {"a": "50", "b": "50"}, {"a": "58", "b": "58"}, {"a": "62", "b": "62"}, {"a": "32", "b": "32"}, {"a": "47", "b": "47"}, {"a": "55", "b": "55"}, {"a": "09", "b": "09"}, {"a": "16", "b": "16"}, {"a": "20", "b": "20"}, {"a": "23", "b": "23"}, {"a": "31", "b": "31"}, {"a": "37", "b": "37"}, {"a": "13", "b": "13"}, {"a": "41", "b": "41"}, {"a": "42", "b": "42"}, {"a": "46", "b": "46"}, {"a": "56", "b": "56"}, {"a": "57", "b": "57"}, {"a": "02", "b": "02"}, {"a": "30", "b": "30"}, {"a": "34", "b": "34"}, {"a": "39", "b": "39"}, {"a": "04", "b": "04"}, {"a": "53", "b": "53"}, {"a": "10", "b": "10"}]}, {"name": "TEN", "vtype": "VARCHAR", "position": "=A22+1", "desc": "Edited Tenure", "column": 29, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "TEN_A", "vtype": "VARCHAR", "position": "=A86+1", "desc": "Edited Tenure Based on Age of Householder", "column": 30, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "TEN_R", "vtype": "VARCHAR", "position": "=A91+1", "desc": "Edited Tenure Based on Householder Race", "column": 31, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "VACS", "vtype": "VARCHAR", "position": "=A96+1", "desc": "Edited Vacancy Status", "column": 32, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "6", "b": "6"}, {"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}, {"a": "7", "b": "7"}]}, {"name": "QGQTYP", "vtype": "VARCHAR", "position": "=A101+1", "desc": "Edited Group Quarters Type Code", "column": 33, "width": 3, "ranges": [{"a": "801", "b": "801"}, {"a": "403", "b": "403"}, {"a": "404", "b": "404"}, {"a": "405", "b": "405"}, {"a": "706", "b": "706"}, {"a": "904", "b": "904"}, {"a": "802", "b": "802"}, {"a": "101", "b": "101"}, {"a": "202", "b": "202"}, {"a": "903", "b": "903"}, {"a": "401", "b": "401"}, {"a": "201", "b": "201"}, {"a": "105", "b": "105"}, {"a": "106", "b": "106"}, {"a": "601", "b": "601"}, {"a": "602", "b": "602"}, {"a": "901", "b": "901"}, {"a": "402", "b": "402"}, {"a": "701", "b": "701"}, {"a": "102", "b": "102"}, {"a": "104", "b": "104"}, {"a": "702", "b": "702"}, {"a": "704", "b": "704"}, {"a": "900", "b": "900"}, {"a": "203", "b": "203"}, {"a": "103", "b": "103"}, {"a": "501", "b": "501"}, {"a": "301", "b": "301"}]}, {"name": "GQSEX", "vtype": "VARCHAR", "position": "=A109+1", "desc": "GQ Unit Sex Composition Flag (from final edited sex)", "column": 36, "width": 1, "ranges": [{"a": "3", "b": "3"}, {"a": "1", "b": "1"}, {"a": "2", "b": "2"}]}, {"name": "OIDTB", "vtype": "NUMBER", "position": "=A138+1", "desc": "Tabulation Block OID", "column": 37, "width": 22, "ranges": []}, {"name": "HHT", "vtype": "VARCHAR", "position": "=A142+1", "desc": "Household/Family Type", "column": 59, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "6", "b": "6"}, {"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}, {"a": "7", "b": "7"}]}, {"name": "HHT2", "vtype": "VARCHAR", "position": "=A143+1", "desc": "Household/Family Type (Includes Cohabiting)", "column": 60, "width": 2, "ranges": [{"a": "05", "b": "05"}, {"a": "11", "b": "11"}, {"a": "07", "b": "07"}, {"a": "08", "b": "08"}, {"a": "09", "b": "09"}, {"a": "12", "b": "12"}, {"a": "03", "b": "03"}, {"a": "06", "b": "06"}, {"a": "02", "b": "02"}, {"a": "01", "b": "01"}, {"a": "00", "b": "00"}, {"a": "04", "b": "04"}, {"a": "10", "b": "10"}]}, {"name": "CPLT", "vtype": "VARCHAR", "position": "=A151+1", "desc": "Couple Type", "column": 62, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "UPART", "vtype": "VARCHAR", "position": "=A164+1", "desc": "Presence and Type of Unmarried Partner Household", "column": 63, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "MULTG", "vtype": "VARCHAR", "position": "=A170+1", "desc": "Multigenerational Household", "column": 64, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}, {"name": "PAOC", "vtype": "VARCHAR", "position": "=A176+1", "desc": "Presence and Age of Own Children Under 18", "column": 65, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "P18", "vtype": "NUMBER", "position": "=A179+1", "desc": "Number of People Under 18 Years in Household", "column": 66, "width": 2, "ranges": [{"a": "1", "b": "99"}, {"a": "0", "b": "0"}]}, {"name": "P60", "vtype": "NUMBER", "position": "=A184+1", "desc": "Number of People 60 Years and Over in Household", "column": 68, "width": 2, "ranges": [{"a": "1", "b": "99"}, {"a": "0", "b": "0"}]}, {"name": "P65", "vtype": "NUMBER", "position": "=A186+1", "desc": "Number of People 65 Years and Over in Household", "column": 70, "width": 2, "ranges": [{"a": "1", "b": "99"}, {"a": "0", "b": "0"}]}, {"name": "P75", "vtype": "NUMBER", "position": "=A188+1", "desc": "Number of People 75 Years and Over in Household", "column": 72, "width": 2, "ranges": [{"a": "1", "b": "99"}, {"a": "0", "b": "0"}]}, {"name": "PAC", "vtype": "VARCHAR", "position": "=A190+1", "desc": "Presence and Age of Children Under 18", "column": 74, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "0", "b": "0"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "HHSEX", "vtype": "VARCHAR", "position": "=A192+1", "desc": "Sex of Householder", "column": 75, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}]}, "CEF20_PER": {"name": "CEF20_PER", "variables": [{"name": "RTYPE", "vtype": "VARCHAR", "position": 1, "desc": "Record Type", "column": 0, "width": 1, "ranges": [{"a": "5", "b": "5"}, {"a": "3", "b": "3"}]}, {"name": "MAFID", "vtype": "NUMBER", "position": 2, "desc": "Master Address File ID.  (The unique identifier of Permanent MAFUNIT ID)", "column": 1, "width": 9, "ranges": [{"a": "100000001", "b": "899999999"}]}, {"name": "CUF_PNC", "vtype": "NUMBER", "position": 3, "desc": "The unique identifier of Unique Person Number.", "column": 10, "width": 5, "ranges": [{"a": "1", "b": "99999"}]}, {"name": "BCUSTATEFP", "vtype": "VARCHAR", "position": "=A7+1", "desc": "FIPS State Code. Basic Collection Unit State Code", "column": 15, "width": 2, "ranges": [{"a": "53", "b": "56"}, {"a": "04", "b": "06"}, {"a": "15", "b": "42"}, {"a": "08", "b": "13"}, {"a": "01", "b": "02"}, {"a": "72", "b": "72"}, {"a": "44", "b": "51"}]}, {"name": "VERSION", "vtype": "NUMBER", "position": "=A8+1", "desc": "Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)", "column": 17, "width": 5, "ranges": [{"a": "00000", "b": "99999"}]}, {"name": "QSEX", "vtype": "VARCHAR", "position": "=A9+1", "desc": "Edited Sex", "column": 22, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "2", "b": "2"}]}, {"name": "QAGE", "vtype": "NUMBER", "position": "=A11+1", "desc": "Edited Age", "column": 23, "width": 3, "ranges": [{"a": "0", "b": "115"}]}, {"name": "QDB", "vtype": "NUMBER", "position": "=A13+1", "desc": "Edited date of birth", "column": 26, "width": 8, "ranges": [{"a": "19040402", "b": "20200401"}]}, {"name": "QDOB_MONTH", "vtype": "NUMBER", "position": "=A14+1", "desc": "Edited Month of Birth", "column": 34, "width": 2, "ranges": [{"a": "1", "b": "12"}]}, {"name": "QDOB_DAY", "vtype": "NUMBER", "position": "=A15+1", "desc": "Edited Day of Birth", "column": 36, "width": 2, "ranges": [{"a": "1", "b": "31"}]}, {"name": "QDOB_YEAR", "vtype": "NUMBER", "position": "=A16+1", "desc": "Edited Year of Birth", "column": 38, "width": 4, "ranges": [{"a": "1904", "b": "2020"}]}, {"name": "QSPAN", "vtype": "NUMBER", "position": "=A17+1", "desc": "Final Edited Hispanic Origin Variable", "column": 42, "width": 4, "ranges": [{"a": "1000", "b": "8999"}, {"a": "9950", "b": "9950"}]}, {"name": "QSPANX", "vtype": "VARCHAR", "position": "=A18+1", "desc": "Edited Hispanic Origin Group (Allocation use only)", "column": 46, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "6", "b": "6"}, {"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}, {"a": "7", "b": "7"}]}, {"name": "CENHISP", "vtype": "NUMBER", "position": "=A19+1", "desc": "A recode of the edited Hispanic origin variable (QSPAN) into two values representing Hispanic and not Hispanic", "column": 47, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "2", "b": "2"}]}, {"name": "QRACE1", "vtype": "NUMBER", "position": "=A26+1", "desc": "Edited First Race Variable", "column": 48, "width": 4, "ranges": [{"a": "1000", "b": "8999"}]}, {"name": "QRACE2", "vtype": "NUMBER", "position": "=A28+1", "desc": "Edited Second Race Variable", "column": 52, "width": 4, "ranges": []}, {"name": "QRACE3", "vtype": "NUMBER", "position": "=A29+1", "desc": "Edited Third Race Variable", "column": 56, "width": 4, "ranges": []}, {"name": "QRACE4", "vtype": "NUMBER", "position": "=A30+1", "desc": "Edited Fourth Race Variable", "column": 60, "width": 4, "ranges": []}, {"name": "QRACE5", "vtype": "NUMBER", "position": "=A31+1", "desc": "Edited Fifth Race Variable", "column": 64, "width": 4, "ranges": []}, {"name": "QRACE6", "vtype": "NUMBER", "position": "=A32+1", "desc": "Edited Sixth Race Variable", "column": 68, "width": 4, "ranges": []}, {"name": "QRACE7", "vtype": "NUMBER", "position": "=A33+1", "desc": "Edited Seventh Race Variable", "column": 72, "width": 4, "ranges": []}, {"name": "QRACE8", "vtype": "NUMBER", "position": "=A34+1", "desc": "Edited Eighth Race Variable", "column": 76, "width": 4, "ranges": []}, {"name": "QRACEX", "vtype": "VARCHAR", "position": "=A35+1", "desc": "Edited Race Group (Allocation use only)", "column": 80, "width": 1, "ranges": [{"a": "1", "b": "1"}, {"a": "6", "b": "6"}, {"a": "5", "b": "5"}, {"a": "4", "b": "4"}, {"a": "2", "b": "2"}, {"a": "3", "b": "3"}]}, {"name": "CENRACE", "vtype": "VARCHAR", "position": "=A36+1", "desc": "A recode of the eight edited race codes (QRACE1-QRACE8) into a single 2-digit code representing all of the possible race categories", "column": 81, "width": 2, "ranges": [{"a": "11", "b": "11"}, {"a": "15", "b": "15"}, {"a": "07", "b": "07"}, {"a": "08", "b": "08"}, {"a": "14", "b": "14"}, {"a": "17", "b": "17"}, {"a": "25", "b": "25"}, {"a": "45", "b": "45"}, {"a": "06", "b": "06"}, {"a": "18", "b": "18"}, {"a": "27", "b": "27"}, {"a": "60", "b": "60"}, {"a": "48", "b": "48"}, {"a": "59", "b": "59"}, {"a": "61", "b": "61"}, {"a": "63", "b": "63"}, {"a": "35", "b": "35"}, {"a": "43", "b": "43"}, {"a": "03", "b": "03"}, {"a": "21", "b": "21"}, {"a": "01", "b": "01"}, {"a": "22", "b": "22"}, {"a": "33", "b": "33"}, {"a": "36", "b": "36"}, {"a": "40", "b": "40"}, {"a": "24", "b": "24"}, {"a": "26", "b": "26"}, {"a": "38", "b": "38"}, {"a": "49", "b": "49"}, {"a": "51", "b": "51"}, {"a": "52", "b": "52"}, {"a": "05", "b": "05"}, {"a": "28", "b": "28"}, {"a": "29", "b": "29"}, {"a": "54", "b": "54"}, {"a": "12", "b": "12"}, {"a": "19", "b": "19"}, {"a": "44", "b": "44"}, {"a": "50", "b": "50"}, {"a": "58", "b": "58"}, {"a": "62", "b": "62"}, {"a": "32", "b": "32"}, {"a": "47", "b": "47"}, {"a": "55", "b": "55"}, {"a": "09", "b": "09"}, {"a": "16", "b": "16"}, {"a": "20", "b": "20"}, {"a": "23", "b": "23"}, {"a": "31", "b": "31"}, {"a": "37", "b": "37"}, {"a": "13", "b": "13"}, {"a": "41", "b": "41"}, {"a": "42", "b": "42"}, {"a": "46", "b": "46"}, {"a": "56", "b": "56"}, {"a": "57", "b": "57"}, {"a": "02", "b": "02"}, {"a": "30", "b": "30"}, {"a": "34", "b": "34"}, {"a": "39", "b": "39"}, {"a": "04", "b": "04"}, {"a": "53", "b": "53"}, {"a": "10", "b": "10"}]}, {"name": "RACE2010", "vtype": "VARCHAR", "position": 25, "desc": "2010 IMPRACE Method:  A recode of the OMB race variables (the non-SOR major race groups)", "column": 83, "width": 2, "ranges": [{"a": "11", "b": "11"}, {"a": "15", "b": "15"}, {"a": "07", "b": "07"}, {"a": "08", "b": "08"}, {"a": "14", "b": "14"}, {"a": "17", "b": "17"}, {"a": "25", "b": "25"}, {"a": "06", "b": "06"}, {"a": "18", "b": "18"}, {"a": "27", "b": "27"}, {"a": "03", "b": "03"}, {"a": "21", "b": "21"}, {"a": "01", "b": "01"}, {"a": "22", "b": "22"}, {"a": "24", "b": "24"}, {"a": "26", "b": "26"}, {"a": "05", "b": "05"}, {"a": "28", "b": "28"}, {"a": "29", "b": "29"}, {"a": "12", "b": "12"}, {"a": "19", "b": "19"}, {"a": "09", "b": "09"}, {"a": "16", "b": "16"}, {"a": "20", "b": "20"}, {"a": "23", "b": "23"}, {"a": "31", "b": "31"}, {"a": "13", "b": "13"}, {"a": "02", "b": "02"}, {"a": "30", "b": "30"}, {"a": "04", "b": "04"}, {"a": "10", "b": "10"}]}, {"name": "RELSHIP", "vtype": "VARCHAR", "position": "=A105+1", "desc": "Final Edited Relationship", "column": 85, "width": 2, "ranges": [{"a": "28", "b": "28"}, {"a": "29", "b": "29"}, {"a": "25", "b": "25"}, {"a": "31", "b": "31"}, {"a": "23", "b": "23"}, {"a": "20", "b": "20"}, {"a": "33", "b": "33"}, {"a": "35", "b": "35"}, {"a": "26", "b": "26"}, {"a": "27", "b": "27"}, {"a": "32", "b": "32"}, {"a": "37", "b": "37"}, {"a": "38", "b": "38"}, {"a": "30", "b": "30"}, {"a": "34", "b": "34"}, {"a": "36", "b": "36"}, {"a": "21", "b": "21"}, {"a": "24", "b": "24"}, {"a": "22", "b": "22"}]}, {"name": "QGQTYP", "vtype": "VARCHAR", "position": "=A164+1", "desc": "Edited Group Quarters Type Code", "column": 87, "width": 3, "ranges": [{"a": "801", "b": "801"}, {"a": "403", "b": "403"}, {"a": "404", "b": "404"}, {"a": "405", "b": "405"}, {"a": "706", "b": "706"}, {"a": "904", "b": "904"}, {"a": "802", "b": "802"}, {"a": "101", "b": "101"}, {"a": "202", "b": "202"}, {"a": "903", "b": "903"}, {"a": "401", "b": "401"}, {"a": "201", "b": "201"}, {"a": "105", "b": "105"}, {"a": "106", "b": "106"}, {"a": "601", "b": "601"}, {"a": "602", "b": "602"}, {"a": "901", "b": "901"}, {"a": "402", "b": "402"}, {"a": "701", "b": "701"}, {"a": "102", "b": "102"}, {"a": "104", "b": "104"}, {"a": "702", "b": "702"}, {"a": "704", "b": "704"}, {"a": "900", "b": "900"}, {"a": "203", "b": "203"}, {"a": "103", "b": "103"}, {"a": "501", "b": "501"}, {"a": "301", "b": "301"}]}, {"name": "LIVE_ALONE", "vtype": "VARCHAR", "position": "=A213+1", "desc": "Person Living Alone", "column": 90, "width": 1, "ranges": [{"a": "2", "b": "2"}, {"a": "1", "b": "1"}, {"a": "0", "b": "0"}]}]}, "CEF20_CNT": {"name": "CEF20_CNT", "variables": [{"name": "BCUSTATEFP", "vtype": "VARCHAR", "position": 1, "desc": "FIPS State Code. Basic Collection Unit State Code (The legal values for this file are 01-02, 04-06, 08-13, 15-42,  44-51, 53-56, and 72.)", "column": 0, "width": 2, "ranges": []}, {"name": "VERSION", "vtype": "NUMBER", "position": "=A4+1", "desc": "Current Version (A version number incremented for each delivery of a particular BCUSTATEFP)", "column": 2, "width": 5, "ranges": []}, {"name": "COUNT_UNIT", "vtype": "NUMBER", "position": "=A5+1", "desc": "Count of units in the BCUSTATEFP", "column": 7, "width": 10, "ranges": []}, {"name": "COUNT_UNIT_HU", "vtype": "NUMBER", "position": "=A6+1", "desc": "Count of Housing Units in the BCUSTATEFP", "column": 17, "width": 10, "ranges": []}, {"name": "COUNT_UNIT_GQ", "vtype": "NUMBER", "position": "=A7+1", "desc": "Count of Group Quarters in the BCUSTATEFP", "column": 27, "width": 10, "ranges": []}, {"name": "COUNT_PER", "vtype": "NUMBER", "position": "=A8+1", "desc": "Count of persons in the BCUSTATEFP", "column": 37, "width": 10, "ranges": []}, {"name": "COUNT_PER_HU", "vtype": "NUMBER", "position": "=A9+1", "desc": "Count of Housing Unit persons in the BCUSTATEFP", "column": 47, "width": 10, "ranges": []}, {"name": "COUNT_PER_GQ", "vtype": "NUMBER", "position": "=A10+1", "desc": "Count of Group Quarters persons in the BCUSTATEFP", "column": 57, "width": 10, "ranges": []}]}}}
